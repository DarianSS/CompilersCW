import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }

  }

  public void syntax_error(Symbol current_token) { report_error(
         "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + "\n", null);
  } 

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INT, RAT, FLOAT, BOOL, CHAR, EQ, SEMICOLON, TOP, 
         PLUS, MINUS, MULT, DIV, POW, INTEGER_LITERAL, FLOAT_LITERAL;
terminal SEQ, DICT;
terminal IDENTIFIER;
terminal LPAREN, RPAREN;
terminal BOOLEAN_LITERAL;
terminal COLON;
terminal STRING;
terminal ANDAND, OROR, CONCAT;
terminal READ;
terminal LBRACE, RBRACE;
terminal RBRACK, LBRACK;
terminal LT, GT;
terminal TDEF, FDEF;
terminal IF, THEN, ELSE, ELIF, FI;
terminal DO, OD;
terminal WHILE;
terminal FORALL, IN;
terminal BADCHAR;
terminal COMMA, DOT; 
terminal AND, OR, NOT;
terminal NOTEQ, EQEQ, LTEQ, GTEQ;
terminal RETURN;
terminal NULL_LITERAL, VOID, ALIAS;
terminal UNDERSCORE;

nonterminal statements, statement, top_level;
nonterminal declaration, full_exp, simple_exp, operator;
nonterminal arithmetic_operator, logic_operator, logic_unary_operator;
nonterminal dict_operator;
nonterminal pos_number, NUMBER;
nonterminal if_statement, if_elif_statement,
            elif_body, elif_segment;
nonterminal prim_type, agg_type, spec_type;
nonterminal while_statement;
nonterminal forall_statement;
nonterminal type;

precedence nonassoc AND, OR, NOT, EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;
precedence left PLUS, MINUS;
precedence left DIV, MULT, POW;


top_level ::= statements;

statements ::= statements statement
             | /* empty */ ;

statement ::= full_exp
            | if_statement
            | if_elif_statement
            | while_statement
            | forall_statement
            | declaration;

full_exp ::= simple_exp SEMICOLON;

simple_exp ::= NUMBER   
             | IDENTIFIER
             | STRING
             | CHAR
             | simple_exp operator simple_exp
             | LPAREN simple_exp RPAREN;

declaration ::= prim_type IDENTIFIER EQ full_exp
              | prim_type IDENTIFIER SEMICOLON
              | SEQ LT CHAR GT IDENTIFIER EQ STRING SEMICOLON;

arithmetic_operator ::= PLUS  
                   | MINUS 
                   | MULT  
                   | DIV   
                   | POW;

logic_operator ::= AND 
                 | OR
                 | EQEQ
                 | NOTEQ
                 | LT
                 | LTEQ
                 | GTEQ 
                 | GT;

logic_unary_operator ::= NOT;

operator ::= arithmetic_operator
           | logic_operator;

dict_operator ::= IDENTIFIER IN IDENTIFIER;

elif_segment ::= ELIF LPAREN simple_exp RPAREN THEN statements;

elif_body ::= elif_segment
            | elif_segment elif_body;

if_statement ::= IF LPAREN simple_exp RPAREN THEN statements FI
               | IF LPAREN simple_exp RPAREN THEN statements ELSE statements FI;

if_elif_statement ::= IF LPAREN simple_exp RPAREN THEN statements elif_body FI
                    | IF LPAREN simple_exp RPAREN THEN statements elif_body ELSE statements FI;

while_statement ::= WHILE LPAREN simple_exp RPAREN DO statements OD;

forall_statement ::= FORALL LPAREN IDENTIFIER IN IDENTIFIER RPAREN DO statements OD;

prim_type ::= INT
            | FLOAT
            | RAT
            | BOOL
            | CHAR;

agg_type ::= SEQ LT spec_type GT
           | DICT LT spec_type COMMA spec_type GT;

spec_type ::= prim_type
            | agg_type
            | TOP;

NUMBER ::= pos_number           
         | MINUS pos_number;

pos_number ::= INTEGER_LITERAL         
             | FLOAT_LITERAL               
             | INTEGER_LITERAL UNDERSCORE INTEGER_LITERAL DIV INTEGER_LITERAL
             | INTEGER_LITERAL DIV INTEGER_LITERAL;