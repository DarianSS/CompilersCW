import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }

  }

  public void syntax_error(Symbol current_token) { report_error(
         "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right + "\n", null);
  } 

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INT, RAT, FLOAT, BOOL, CHAR, EQ, SEMICOLON, TOP, 
         PLUS, MINUS, MULT, DIV, POW, INTEGER_LITERAL, FLOAT_LITERAL;
terminal SEQ, DICT;
terminal IDENTIFIER;
terminal LPAREN, RPAREN;
terminal BOOLEAN_LITERAL;
terminal COLON;
terminal STRING;
terminal ANDAND, OROR, CONCAT;
terminal READ, PRINT;
terminal LBRACE, RBRACE;
terminal RBRACK, LBRACK;
terminal LT, GT;
terminal TDEF, FDEF;
terminal IF, THEN, ELSE, ELIF, FI;
terminal DO, OD;
terminal WHILE;
terminal FORALL, IN;
terminal BADCHAR;
terminal COMMA, DOT; 
terminal AND, OR, NOT;
terminal NOTEQ, EQEQ, LTEQ, GTEQ;
terminal RETURN;
terminal NULL_LITERAL, VOID, ALIAS;
terminal UNDERSCORE;

nonterminal statements, statement, top_level;
nonterminal declaration, full_exp, simple_exp, operator;
nonterminal seq_declaration, seq_dec_list;
nonterminal dict_declaration, dict_dec_list;
nonterminal tdef_declaration;
nonterminal arithmetic_operator, logic_operator, logic_unary_operator;
nonterminal dict_operator;
nonterminal pos_number, number;
nonterminal if_statement, if_elif_statement,
            elif_body, elif_segment;
nonterminal prim_type, agg_type, spec_type;
nonterminal while_statement;
nonterminal forall_statement;
nonterminal type;
nonterminal declaration_list, declaration_list_item;
nonterminal alias, tdef;
nonterminal fdef, formal_parameter_list, formal_parameter_list_item;
nonterminal array_access;

precedence nonassoc AND, OR, NOT, EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;
precedence left PLUS, MINUS;
precedence left DIV, MULT, POW;
precedence left IDENTIFIER;


top_level ::= statements;

statements ::= statements statement
             | /* empty */ ;

statement ::= full_exp
            | if_statement
            | if_elif_statement
            | while_statement
            | forall_statement
            | declaration
            | tdef
            | fdef
            | alias
            | RETURN full_exp
            | READ IDENTIFIER SEMICOLON
            | PRINT full_exp;

full_exp ::= simple_exp SEMICOLON;

simple_exp ::= number   
             | IDENTIFIER
             | STRING
             | CHAR
             | simple_exp operator simple_exp
             | LPAREN simple_exp RPAREN
             | array_access
             | IDENTIFIER DOT IDENTIFIER; 

declaration ::= prim_type IDENTIFIER EQ full_exp
              | prim_type IDENTIFIER SEMICOLON
              | IDENTIFIER EQ full_exp
              | seq_declaration
              | dict_declaration
              | tdef_declaration;

tdef_declaration ::= IDENTIFIER IDENTIFIER EQ seq_dec_list;

seq_declaration ::= SEQ LT spec_type GT IDENTIFIER SEMICOLON
                  | SEQ LT CHAR GT IDENTIFIER EQ STRING SEMICOLON
                  | SEQ LT spec_type GT IDENTIFIER EQ LBRACK seq_dec_list RBRACK SEMICOLON;

seq_dec_list ::= simple_exp COMMA seq_dec_list
               | simple_exp;

dict_declaration ::= DICT LT spec_type COMMA spec_type GT IDENTIFIER SEMICOLON
                   | DICT LT spec_type COMMA spec_type GT IDENTIFIER EQ LBRACE dict_dec_list RBRACE SEMICOLON;

dict_dec_list ::= simple_exp COLON simple_exp COMMA dict_dec_list
                | simple_exp COLON simple_exp;                    

arithmetic_operator ::= PLUS  
                   | MINUS 
                   | MULT  
                   | DIV   
                   | POW;

logic_operator ::= AND 
                 | OR
                 | EQEQ
                 | NOTEQ
                 | LT
                 | LTEQ
                 | GTEQ 
                 | GT;

logic_unary_operator ::= NOT;

operator ::= arithmetic_operator
           | logic_operator;

dict_operator ::= IDENTIFIER IN IDENTIFIER;

elif_segment ::= ELIF LPAREN simple_exp RPAREN THEN statements;

elif_body ::= elif_segment
            | elif_segment elif_body;

if_statement ::= IF LPAREN simple_exp RPAREN THEN statements FI
               | IF LPAREN simple_exp RPAREN THEN statements ELSE statements FI;

if_elif_statement ::= IF LPAREN simple_exp RPAREN THEN statements elif_body FI
                    | IF LPAREN simple_exp RPAREN THEN statements elif_body ELSE statements FI;

while_statement ::= WHILE LPAREN simple_exp RPAREN DO statements OD;

forall_statement ::= FORALL LPAREN IDENTIFIER IN IDENTIFIER RPAREN DO statements OD;

prim_type ::= INT
            | FLOAT
            | RAT
            | BOOL
            | CHAR
            | IDENTIFIER;

agg_type ::= SEQ LT spec_type GT
           | DICT LT spec_type COMMA spec_type GT;

spec_type ::= prim_type
            | agg_type
            | TOP;

declaration_list ::= declaration_list COMMA declaration_list_item
                   | declaration_list_item;

declaration_list_item ::= prim_type IDENTIFIER
                        | agg_type IDENTIFIER;

alias ::= ALIAS spec_type IDENTIFIER SEMICOLON;

tdef ::= TDEF IDENTIFIER LBRACE declaration_list RBRACE SEMICOLON;

fdef ::= FDEF prim_type IDENTIFIER LPAREN formal_parameter_list RPAREN LBRACE statements RBRACE SEMICOLON
       |FDEF agg_type IDENTIFIER LPAREN formal_parameter_list RPAREN LBRACE statements RBRACE SEMICOLON;

formal_parameter_list ::= formal_parameter_list COMMA formal_parameter_list_item
                        | formal_parameter_list_item;

formal_parameter_list_item ::= prim_type IDENTIFIER
                             | agg_type IDENTIFIER;

array_access ::= IDENTIFIER LBRACK simple_exp RBRACK
               | IDENTIFIER LBRACK simple_exp COLON simple_exp RBRACK
               | IDENTIFIER LBRACK COLON simple_exp RBRACK
               | IDENTIFIER LBRACK simple_exp COLON RBRACK;



number ::= pos_number           
         | MINUS pos_number;

pos_number ::= INTEGER_LITERAL         
             | FLOAT_LITERAL               
             | INTEGER_LITERAL UNDERSCORE INTEGER_LITERAL DIV INTEGER_LITERAL
             | INTEGER_LITERAL DIV INTEGER_LITERAL;